/*
 * Zynaptic Relay MQTTv3 - An MQTT version 3.1.1 implementation for Java.
 *
 * Copyright (c) 2019, Zynaptic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 * Please visit www.zynaptic.com or contact reaction@zynaptic.com if you need
 * additional information or have any questions.
 */

package com.zynaptic.relay.mqttv3.core;

import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.CodingErrorAction;
import java.nio.charset.StandardCharsets;
import java.util.regex.Pattern;

/**
 * Implements the UTF-8 validated string data type for encoding MQTT payload
 * strings.
 *
 * @author Chris Holgate
 */
final class ValidatedString {

  private final String string;
  private final byte[] byteEncoding;

  // Regulat expression pattern used to check for invalid UTF characters.
  private static final Pattern STRING_VALIDATION_PATTERN = Pattern
      .compile("^[^\u0000-\u001F\u007F-\u009F\uD800-\uDFFF]*$");

  // Regular expression pattern used to check for valid topic names.
  private static final Pattern TOPIC_NAME_VALIDATION_PATTERN = Pattern.compile("^[^\\+\\#]*$");

  /**
   * Provides private constructor for generating new instances via the static
   * create methods.
   *
   * @param string This is the Java native string which is encoded as a UTF-8 byte
   *   array.
   * @param byteEncoding This is the UTF-8 byte encoding of the string.
   */
  private ValidatedString(final String string, final byte[] byteEncoding) {
    this.string = string;
    this.byteEncoding = byteEncoding;
  }

  /**
   * Static method for creating a new validated string from the UTF-8 encoded byte
   * array located at the current position of a byte buffer.
   *
   * @param byteBuffer This is the byte buffer which contains the UTF-8 encoded
   *   string.
   * @return Returns a newly created validated string, generated by parsing the
   *   input byte buffer.
   * @throws CharacterCodingException This exception will be thrown if the encoded
   *   byte array contains invalid characters.
   * @throws BufferUnderflowException This exception will be thrown if a buffer
   *   underflow was encountered while parsing the validated string.
   */
  static ValidatedString create(final ByteBuffer byteBuffer) throws CharacterCodingException, BufferUnderflowException {
    if (byteBuffer == null) {
      return null;
    }
    final int length = 0xFFFF & byteBuffer.getShort();
    final byte[] byteEncoding = new byte[length + 2];
    byteEncoding[0] = (byte) (length >> 8);
    byteEncoding[1] = (byte) (length);
    byteBuffer.get(byteEncoding, 2, length);
    final CharsetDecoder utf8Decoder = StandardCharsets.UTF_8.newDecoder();
    utf8Decoder.onMalformedInput(CodingErrorAction.REPORT);
    final CharBuffer charBuffer = utf8Decoder.decode(ByteBuffer.wrap(byteEncoding, 2, length));
    final String string = charBuffer.toString();
    if (!STRING_VALIDATION_PATTERN.matcher(string).matches()) {
      throw new CharacterCodingException();
    }
    return new ValidatedString(string, byteEncoding);
  }

  /**
   * Static method for creating a new validated string from a standard Java string
   * object.
   *
   * @param string This is the standard Java string object which is to be
   *   validated and UTF-8 encoded.
   * @return Returns a newly created validated string, generated by encoding the
   *   input string.
   * @throws CharacterCodingException This exception will be thrown if the encoded
   *   byte array contains invalid characters.
   */
  static ValidatedString create(final String string) throws CharacterCodingException {
    if (string == null) {
      return null;
    }
    if (!STRING_VALIDATION_PATTERN.matcher(string).matches()) {
      throw new CharacterCodingException();
    }
    final CharsetEncoder utf8Encoder = StandardCharsets.UTF_8.newEncoder();
    utf8Encoder.onMalformedInput(CodingErrorAction.REPORT);
    final ByteBuffer byteBuffer = utf8Encoder.encode(CharBuffer.wrap(string));
    if (byteBuffer.remaining() > 0xFFFF) {
      throw new IllegalArgumentException("Encoded string exceeds the maximum supported length");
    }
    final byte[] byteEncoding = new byte[byteBuffer.remaining() + 2];
    byteEncoding[0] = (byte) (byteBuffer.remaining() >> 8);
    byteEncoding[1] = (byte) (byteBuffer.remaining());
    byteBuffer.get(byteEncoding, 2, byteBuffer.remaining());
    return new ValidatedString(string, byteEncoding);
  }

  /**
   * Static method for creating a new validated string from a UTF-8 encoded byte
   * array.
   *
   * @param byteArray This is the byte array which is to be converted to a
   *   validated string.
   * @return Returns a newly created validated string, generated by decoding the
   *   input byte array.
   * @throws CharacterCodingException This exception will be thrown if the encoded
   *   byte array contains invalid characters.
   */
  static ValidatedString create(final byte[] byteArray) throws CharacterCodingException {
    if (byteArray == null) {
      return null;
    }
    final byte[] byteEncoding = new byte[byteArray.length + 2];
    byteEncoding[0] = (byte) (byteArray.length >> 8);
    byteEncoding[1] = (byte) (byteArray.length);
    System.arraycopy(byteArray, 0, byteEncoding, 2, byteArray.length);
    final CharsetDecoder utf8Decoder = StandardCharsets.UTF_8.newDecoder();
    utf8Decoder.onMalformedInput(CodingErrorAction.REPORT);
    final CharBuffer charBuffer = utf8Decoder.decode(ByteBuffer.wrap(byteArray));
    final String string = charBuffer.toString();
    if (!STRING_VALIDATION_PATTERN.matcher(string).matches()) {
      throw new CharacterCodingException();
    }
    return new ValidatedString(string, byteEncoding);
  }

  /**
   * Accesses the Java native string that is encoded as a valid UTF-8 byte array.
   *
   * @return Returns the Java native validated string.
   */
  String getString() {
    return string;
  }

  /**
   * Accesses the UTF-8 byte encoding for the validated string. This includes the
   * two leading length bytes, as required by the MQTT specification.
   *
   * @return Returns the UTF-8 byte encoding for the validated string.
   */
  byte[] getByteEncoding() {
    return byteEncoding;
  }

  /**
   * Indicates whether the validated string is also a valid MQTT topic name.
   *
   * @return Returns a boolean value which will be set to 'true' if the validated
   *   string is also a valid MQTT topic name and 'false' otherwise.
   */
  boolean isValidTopicName() {
    return TOPIC_NAME_VALIDATION_PATTERN.matcher(string).matches();
  }
}
